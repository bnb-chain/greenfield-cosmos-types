/* eslint-disable */
import { VoteResult, voteResultFromJSON, voteResultToJSON } from "./types";
import { Long, isSet, DeepPartial, Exact } from "../../helpers";
import * as _m0 from "protobufjs/minimal";
export const protobufPackage = "bnbchain.greenfield.challenge";
export interface EventStartChallenge {
  /** The id of challenge, which is generated by blockchain. */
  challengeId: Long;
  /** The id of object info to be challenged. */

  objectId: string;
  /** The segment/piece index of the object info. */

  segmentIndex: number;
  /** The storage provider to be challenged. */

  spOperatorAddress: string;
  /** The redundancy index, which comes from the index of storage providers. */

  redundancyIndex: number;
  /** The challenger who submits the challenge. */

  challengerAddress: string;
}
export interface EventAttestChallenge {
  /** The id of challenge. */
  challengeId: Long;
  /** The result of challenge. */

  result: VoteResult;
  /** The slashed storage provider address. */

  spOperatorAddress: string;
  /** The slashed amount from the storage provider. */

  slashAmount: string;
  /** The address of challenger. */

  challengerAddress: string;
  /** The reward amount to the challenger. */

  challengerRewardAmount: string;
  /** The submitter of challenge attestation. */

  submitterAddress: string;
  /** The reward amount to the submitter. */

  submitterRewardAmount: string;
  /** The reward amount to all validators. */

  validatorRewardAmount: string;
}

function createBaseEventStartChallenge(): EventStartChallenge {
  return {
    challengeId: Long.UZERO,
    objectId: "",
    segmentIndex: 0,
    spOperatorAddress: "",
    redundancyIndex: 0,
    challengerAddress: ""
  };
}

export const EventStartChallenge = {
  encode(message: EventStartChallenge, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.challengeId.isZero()) {
      writer.uint32(8).uint64(message.challengeId);
    }

    if (message.objectId !== "") {
      writer.uint32(18).string(message.objectId);
    }

    if (message.segmentIndex !== 0) {
      writer.uint32(24).uint32(message.segmentIndex);
    }

    if (message.spOperatorAddress !== "") {
      writer.uint32(34).string(message.spOperatorAddress);
    }

    if (message.redundancyIndex !== 0) {
      writer.uint32(40).int32(message.redundancyIndex);
    }

    if (message.challengerAddress !== "") {
      writer.uint32(50).string(message.challengerAddress);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventStartChallenge {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventStartChallenge();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.challengeId = (reader.uint64() as Long);
          break;

        case 2:
          message.objectId = reader.string();
          break;

        case 3:
          message.segmentIndex = reader.uint32();
          break;

        case 4:
          message.spOperatorAddress = reader.string();
          break;

        case 5:
          message.redundancyIndex = reader.int32();
          break;

        case 6:
          message.challengerAddress = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): EventStartChallenge {
    return {
      challengeId: isSet(object.challengeId) ? Long.fromValue(object.challengeId) : Long.UZERO,
      objectId: isSet(object.objectId) ? String(object.objectId) : "",
      segmentIndex: isSet(object.segmentIndex) ? Number(object.segmentIndex) : 0,
      spOperatorAddress: isSet(object.spOperatorAddress) ? String(object.spOperatorAddress) : "",
      redundancyIndex: isSet(object.redundancyIndex) ? Number(object.redundancyIndex) : 0,
      challengerAddress: isSet(object.challengerAddress) ? String(object.challengerAddress) : ""
    };
  },

  toJSON(message: EventStartChallenge): unknown {
    const obj: any = {};
    message.challengeId !== undefined && (obj.challengeId = (message.challengeId || Long.UZERO).toString());
    message.objectId !== undefined && (obj.objectId = message.objectId);
    message.segmentIndex !== undefined && (obj.segmentIndex = Math.round(message.segmentIndex));
    message.spOperatorAddress !== undefined && (obj.spOperatorAddress = message.spOperatorAddress);
    message.redundancyIndex !== undefined && (obj.redundancyIndex = Math.round(message.redundancyIndex));
    message.challengerAddress !== undefined && (obj.challengerAddress = message.challengerAddress);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EventStartChallenge>, I>>(object: I): EventStartChallenge {
    const message = createBaseEventStartChallenge();
    message.challengeId = object.challengeId !== undefined && object.challengeId !== null ? Long.fromValue(object.challengeId) : Long.UZERO;
    message.objectId = object.objectId ?? "";
    message.segmentIndex = object.segmentIndex ?? 0;
    message.spOperatorAddress = object.spOperatorAddress ?? "";
    message.redundancyIndex = object.redundancyIndex ?? 0;
    message.challengerAddress = object.challengerAddress ?? "";
    return message;
  }

};

function createBaseEventAttestChallenge(): EventAttestChallenge {
  return {
    challengeId: Long.UZERO,
    result: 0,
    spOperatorAddress: "",
    slashAmount: "",
    challengerAddress: "",
    challengerRewardAmount: "",
    submitterAddress: "",
    submitterRewardAmount: "",
    validatorRewardAmount: ""
  };
}

export const EventAttestChallenge = {
  encode(message: EventAttestChallenge, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (!message.challengeId.isZero()) {
      writer.uint32(8).uint64(message.challengeId);
    }

    if (message.result !== 0) {
      writer.uint32(16).int32(message.result);
    }

    if (message.spOperatorAddress !== "") {
      writer.uint32(26).string(message.spOperatorAddress);
    }

    if (message.slashAmount !== "") {
      writer.uint32(34).string(message.slashAmount);
    }

    if (message.challengerAddress !== "") {
      writer.uint32(42).string(message.challengerAddress);
    }

    if (message.challengerRewardAmount !== "") {
      writer.uint32(50).string(message.challengerRewardAmount);
    }

    if (message.submitterAddress !== "") {
      writer.uint32(58).string(message.submitterAddress);
    }

    if (message.submitterRewardAmount !== "") {
      writer.uint32(66).string(message.submitterRewardAmount);
    }

    if (message.validatorRewardAmount !== "") {
      writer.uint32(82).string(message.validatorRewardAmount);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventAttestChallenge {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventAttestChallenge();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.challengeId = (reader.uint64() as Long);
          break;

        case 2:
          message.result = (reader.int32() as any);
          break;

        case 3:
          message.spOperatorAddress = reader.string();
          break;

        case 4:
          message.slashAmount = reader.string();
          break;

        case 5:
          message.challengerAddress = reader.string();
          break;

        case 6:
          message.challengerRewardAmount = reader.string();
          break;

        case 7:
          message.submitterAddress = reader.string();
          break;

        case 8:
          message.submitterRewardAmount = reader.string();
          break;

        case 10:
          message.validatorRewardAmount = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): EventAttestChallenge {
    return {
      challengeId: isSet(object.challengeId) ? Long.fromValue(object.challengeId) : Long.UZERO,
      result: isSet(object.result) ? voteResultFromJSON(object.result) : 0,
      spOperatorAddress: isSet(object.spOperatorAddress) ? String(object.spOperatorAddress) : "",
      slashAmount: isSet(object.slashAmount) ? String(object.slashAmount) : "",
      challengerAddress: isSet(object.challengerAddress) ? String(object.challengerAddress) : "",
      challengerRewardAmount: isSet(object.challengerRewardAmount) ? String(object.challengerRewardAmount) : "",
      submitterAddress: isSet(object.submitterAddress) ? String(object.submitterAddress) : "",
      submitterRewardAmount: isSet(object.submitterRewardAmount) ? String(object.submitterRewardAmount) : "",
      validatorRewardAmount: isSet(object.validatorRewardAmount) ? String(object.validatorRewardAmount) : ""
    };
  },

  toJSON(message: EventAttestChallenge): unknown {
    const obj: any = {};
    message.challengeId !== undefined && (obj.challengeId = (message.challengeId || Long.UZERO).toString());
    message.result !== undefined && (obj.result = voteResultToJSON(message.result));
    message.spOperatorAddress !== undefined && (obj.spOperatorAddress = message.spOperatorAddress);
    message.slashAmount !== undefined && (obj.slashAmount = message.slashAmount);
    message.challengerAddress !== undefined && (obj.challengerAddress = message.challengerAddress);
    message.challengerRewardAmount !== undefined && (obj.challengerRewardAmount = message.challengerRewardAmount);
    message.submitterAddress !== undefined && (obj.submitterAddress = message.submitterAddress);
    message.submitterRewardAmount !== undefined && (obj.submitterRewardAmount = message.submitterRewardAmount);
    message.validatorRewardAmount !== undefined && (obj.validatorRewardAmount = message.validatorRewardAmount);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EventAttestChallenge>, I>>(object: I): EventAttestChallenge {
    const message = createBaseEventAttestChallenge();
    message.challengeId = object.challengeId !== undefined && object.challengeId !== null ? Long.fromValue(object.challengeId) : Long.UZERO;
    message.result = object.result ?? 0;
    message.spOperatorAddress = object.spOperatorAddress ?? "";
    message.slashAmount = object.slashAmount ?? "";
    message.challengerAddress = object.challengerAddress ?? "";
    message.challengerRewardAmount = object.challengerRewardAmount ?? "";
    message.submitterAddress = object.submitterAddress ?? "";
    message.submitterRewardAmount = object.submitterRewardAmount ?? "";
    message.validatorRewardAmount = object.validatorRewardAmount ?? "";
    return message;
  }

};