/* eslint-disable */
import { SourceType, ObjectStatus, RedundancyType, sourceTypeFromJSON, sourceTypeToJSON, objectStatusFromJSON, redundancyTypeFromJSON, objectStatusToJSON, redundancyTypeToJSON } from "./common";
import { Long, isSet, DeepPartial, Exact, bytesFromBase64, base64FromBytes } from "../../helpers";
import * as _m0 from "protobufjs/minimal";
export const protobufPackage = "bnbchain.greenfield.storage";
/** EventCreateBucket is emitted on MsgCreateBucket */

export interface EventCreateBucket {
  /** owner_address define the account address of bucket owner */
  owner_address: string;
  /** bucket_name is a globally unique name of bucket */

  bucket_name: string;
  /** is_public define the highest permissions for bucket. When the bucket is public, everyone can get the object in it. */

  is_public: boolean;
  /** create_at define the block number when the bucket has been created */

  create_at: Long;
  /** id is the unique u256 for bucket. Not global, only unique in buckets. */

  id: string;
  /** source_type define the source of the bucket. CrossChain or Greenfield origin */

  source_type: SourceType;
  /** read_quota defines the traffic quota for read */

  read_quota: Long;
  /** payment_address is the address of the payment account */

  payment_address: string;
  /** primary_sp_address is the operator address of the primary sp. */

  primary_sp_address: string;
}
/** EventDeleteBucket is emitted on MsgDeleteBucket */

export interface EventDeleteBucket {
  /** operator_address define the account address of operator who delete the bucket */
  operator_address: string;
  /** owner_address define the account address of the bucket owner */

  owner_address: string;
  /** bucket_name define the name of the deleted bucket */

  bucket_name: string;
  /** id define an u256 id for bucket */

  id: string;
  /** primary_sp_address define the account address of primary sp */

  primary_sp_address: string;
}
/** EventUpdateBucketInfo is emitted on MsgUpdateBucketInfo */

export interface EventUpdateBucketInfo {
  /** operator_address define the account address of operator who update the bucket */
  operator_address: string;
  /** bucket_name define the name of the bucket */

  bucket_name: string;
  /** id define an u256 id for bucket */

  id: string;
  /** read_quota_before define the read quota before updated */

  read_quota_before: Long;
  /** read_quota_after define the read quota after updated */

  read_quota_after: Long;
  /** payment_address_before define the payment address before updated */

  payment_address_before: string;
  /** payment_address_after define the payment address after updated */

  payment_address_after: string;
}
/** EventCreateObject is emitted on MsgCreateObject */

export interface EventCreateObject {
  /** creator_address define the account address of msg creator */
  creator_address: string;
  /** owner_address define the account address of object owner */

  owner_address: string;
  /** bucket_name define the name of bucket */

  bucket_name: string;
  /** object_name define the name of object */

  object_name: string;
  /** bucket_id define an u256 id for object */

  bucket_id: string;
  /** object_id define an u256 id for object */

  object_id: string;
  /** primary_sp_address define the account address of primary sp */

  primary_sp_address: string;
  /** payload_size define the size of payload data which you want upload */

  payload_size: Long;
  /** is_public define the highest permission of object. */

  is_public: boolean;
  /** content_type define the content type of the payload data */

  content_type: string;
  /** create_at define the block number when the object created */

  create_at: Long;
  /** status define the status of the object. INIT or IN_SERVICE or others */

  status: ObjectStatus;
  /** redundancy_type define the type of redundancy. Replication or EC */

  redundancy_type: RedundancyType;
  /** source_type define the source of the object.  CrossChain or Greenfield origin */

  source_type: SourceType;
  /** checksums define the total checksums of the object which generated by redundancy */

  checksums: Uint8Array[];
}
/** EventSealObject is emitted on MsgSealObject */

export interface EventCancelCreateObject {
  /** operator_address define the account address of operator who cancel create object */
  operator_address: string;
  /** bucket_name define the name of the bucket */

  bucket_name: string;
  /** object_name define the name of the object */

  object_name: string;
  /** primary_sp_address define the operator account address of the sp */

  primary_sp_address: string;
  /** id define an u256 id for object */

  id: string;
}
/** EventSealObject is emitted on MsgSealObject */

export interface EventSealObject {
  /** operator_address define the account address of operator who seal object */
  operator_address: string;
  /** bucket_name define the name of the bucket */

  bucket_name: string;
  /** object_name define the name of the object */

  object_name: string;
  /** id define an u256 id for object */

  id: string;
  /** status define the status of the object. INIT or IN_SERVICE or others */

  status: ObjectStatus;
  /** secondary_sp_address define all the operator address of the secondary sps */

  secondary_sp_address: string[];
}
/** EventCopyObject is emitted on MsgCopyObject */

export interface EventCopyObject {
  /** operator_address define the account address of operator who copy the object */
  operator_address: string;
  /** src_bucket_name define the name of the src bucket */

  src_bucket_name: string;
  /** src_object_name define the name of the src object */

  src_object_name: string;
  /** dst_bucket_name define the name of the dst bucket */

  dst_bucket_name: string;
  /** dst_object_name define the name of the dst object */

  dst_object_name: string;
  /** src_object_id define the u256 id for src object */

  src_object_id: string;
  /** dst_object_id define the u256 id for dst object */

  dst_object_id: string;
}
/** EventDeleteObject is emitted on MsgDeleteObject */

export interface EventDeleteObject {
  /** operator_address define the account address of operator who delete the object */
  operator_address: string;
  /** bucket_name define the name of the bucket */

  bucket_name: string;
  /** object_name define the name of the object */

  object_name: string;
  /** id define an u256 id for object */

  id: string;
  /** primary_sp_address define the operator account address of the sp */

  primary_sp_address: string;
  /** secondary_sp_address define all the operator address of the secondary sps */

  secondary_sp_addresses: string[];
}
/** EventRejectSealObject is emitted on MsgRejectSealObject */

export interface EventRejectSealObject {
  /** operator_address define the account address of operator who reject seal object */
  operator_address: string;
  /** bucket_name define the name of the bucket */

  bucket_name: string;
  /** object_name define the name of the object */

  object_name: string;
  /** id define an u256 id for object */

  id: string;
}
/** EventCreateGroup is emitted on MsgCreateGroup */

export interface EventCreateGroup {
  /** owner_address define the account address of group owner */
  owner_address: string;
  /** group_name define the name of the group */

  group_name: string;
  /** id define an u256 id for group */

  id: string;
  /** source_type define the source of the group. CrossChain or Greenfield origin */

  source_type: SourceType;
  /** members define the all the address of the members. */

  members: string[];
}
/** EventDeleteGroup is emitted on MsgDeleteGroup */

export interface EventDeleteGroup {
  /** owner_address define the account address of group owner */
  owner_address: string;
  /** group_name define the name of the group */

  group_name: string;
  /** id define an u256 id for group */

  id: string;
}
/** EventLeaveGroup is emitted on MsgLeaveGroup */

export interface EventLeaveGroup {
  /** member_address define the address of the member who leave the group */
  member_address: string;
  /** owner_address define the account address of group owner */

  owner_address: string;
  /** group_name define the name of the group */

  group_name: string;
  /** id define an u256 id for group */

  id: string;
}
/** EventUpdateGroupMember is emitted on MsgUpdateGroupMember */

export interface EventUpdateGroupMember {
  /** operator_address define the account address of operator who update the group member */
  operator_address: string;
  /** owner_address define the account address of group owner */

  owner_address: string;
  /** group_name define the name of the group */

  group_name: string;
  /** id define an u256 id for group */

  id: string;
  /** members_to_add defines all the members to be added to the group */

  members_to_add: string[];
  /** members_to_add defines all the members to be deleted from the group */

  members_to_delete: string[];
}

function createBaseEventCreateBucket(): EventCreateBucket {
  return {
    owner_address: "",
    bucket_name: "",
    is_public: false,
    create_at: Long.ZERO,
    id: "",
    source_type: 0,
    read_quota: Long.UZERO,
    payment_address: "",
    primary_sp_address: ""
  };
}

export const EventCreateBucket = {
  encode(message: EventCreateBucket, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.owner_address !== "") {
      writer.uint32(10).string(message.owner_address);
    }

    if (message.bucket_name !== "") {
      writer.uint32(18).string(message.bucket_name);
    }

    if (message.is_public === true) {
      writer.uint32(24).bool(message.is_public);
    }

    if (!message.create_at.isZero()) {
      writer.uint32(32).int64(message.create_at);
    }

    if (message.id !== "") {
      writer.uint32(42).string(message.id);
    }

    if (message.source_type !== 0) {
      writer.uint32(48).int32(message.source_type);
    }

    if (!message.read_quota.isZero()) {
      writer.uint32(56).uint64(message.read_quota);
    }

    if (message.payment_address !== "") {
      writer.uint32(66).string(message.payment_address);
    }

    if (message.primary_sp_address !== "") {
      writer.uint32(74).string(message.primary_sp_address);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventCreateBucket {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventCreateBucket();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.owner_address = reader.string();
          break;

        case 2:
          message.bucket_name = reader.string();
          break;

        case 3:
          message.is_public = reader.bool();
          break;

        case 4:
          message.create_at = (reader.int64() as Long);
          break;

        case 5:
          message.id = reader.string();
          break;

        case 6:
          message.source_type = (reader.int32() as any);
          break;

        case 7:
          message.read_quota = (reader.uint64() as Long);
          break;

        case 8:
          message.payment_address = reader.string();
          break;

        case 9:
          message.primary_sp_address = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): EventCreateBucket {
    return {
      owner_address: isSet(object.owner_address) ? String(object.owner_address) : "",
      bucket_name: isSet(object.bucket_name) ? String(object.bucket_name) : "",
      is_public: isSet(object.is_public) ? Boolean(object.is_public) : false,
      create_at: isSet(object.create_at) ? Long.fromValue(object.create_at) : Long.ZERO,
      id: isSet(object.id) ? String(object.id) : "",
      source_type: isSet(object.source_type) ? sourceTypeFromJSON(object.source_type) : 0,
      read_quota: isSet(object.read_quota) ? Long.fromValue(object.read_quota) : Long.UZERO,
      payment_address: isSet(object.payment_address) ? String(object.payment_address) : "",
      primary_sp_address: isSet(object.primary_sp_address) ? String(object.primary_sp_address) : ""
    };
  },

  toJSON(message: EventCreateBucket): unknown {
    const obj: any = {};
    message.owner_address !== undefined && (obj.owner_address = message.owner_address);
    message.bucket_name !== undefined && (obj.bucket_name = message.bucket_name);
    message.is_public !== undefined && (obj.is_public = message.is_public);
    message.create_at !== undefined && (obj.create_at = (message.create_at || Long.ZERO).toString());
    message.id !== undefined && (obj.id = message.id);
    message.source_type !== undefined && (obj.source_type = sourceTypeToJSON(message.source_type));
    message.read_quota !== undefined && (obj.read_quota = (message.read_quota || Long.UZERO).toString());
    message.payment_address !== undefined && (obj.payment_address = message.payment_address);
    message.primary_sp_address !== undefined && (obj.primary_sp_address = message.primary_sp_address);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EventCreateBucket>, I>>(object: I): EventCreateBucket {
    const message = createBaseEventCreateBucket();
    message.owner_address = object.owner_address ?? "";
    message.bucket_name = object.bucket_name ?? "";
    message.is_public = object.is_public ?? false;
    message.create_at = object.create_at !== undefined && object.create_at !== null ? Long.fromValue(object.create_at) : Long.ZERO;
    message.id = object.id ?? "";
    message.source_type = object.source_type ?? 0;
    message.read_quota = object.read_quota !== undefined && object.read_quota !== null ? Long.fromValue(object.read_quota) : Long.UZERO;
    message.payment_address = object.payment_address ?? "";
    message.primary_sp_address = object.primary_sp_address ?? "";
    return message;
  }

};

function createBaseEventDeleteBucket(): EventDeleteBucket {
  return {
    operator_address: "",
    owner_address: "",
    bucket_name: "",
    id: "",
    primary_sp_address: ""
  };
}

export const EventDeleteBucket = {
  encode(message: EventDeleteBucket, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.operator_address !== "") {
      writer.uint32(10).string(message.operator_address);
    }

    if (message.owner_address !== "") {
      writer.uint32(18).string(message.owner_address);
    }

    if (message.bucket_name !== "") {
      writer.uint32(26).string(message.bucket_name);
    }

    if (message.id !== "") {
      writer.uint32(34).string(message.id);
    }

    if (message.primary_sp_address !== "") {
      writer.uint32(42).string(message.primary_sp_address);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventDeleteBucket {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventDeleteBucket();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.operator_address = reader.string();
          break;

        case 2:
          message.owner_address = reader.string();
          break;

        case 3:
          message.bucket_name = reader.string();
          break;

        case 4:
          message.id = reader.string();
          break;

        case 5:
          message.primary_sp_address = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): EventDeleteBucket {
    return {
      operator_address: isSet(object.operator_address) ? String(object.operator_address) : "",
      owner_address: isSet(object.owner_address) ? String(object.owner_address) : "",
      bucket_name: isSet(object.bucket_name) ? String(object.bucket_name) : "",
      id: isSet(object.id) ? String(object.id) : "",
      primary_sp_address: isSet(object.primary_sp_address) ? String(object.primary_sp_address) : ""
    };
  },

  toJSON(message: EventDeleteBucket): unknown {
    const obj: any = {};
    message.operator_address !== undefined && (obj.operator_address = message.operator_address);
    message.owner_address !== undefined && (obj.owner_address = message.owner_address);
    message.bucket_name !== undefined && (obj.bucket_name = message.bucket_name);
    message.id !== undefined && (obj.id = message.id);
    message.primary_sp_address !== undefined && (obj.primary_sp_address = message.primary_sp_address);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EventDeleteBucket>, I>>(object: I): EventDeleteBucket {
    const message = createBaseEventDeleteBucket();
    message.operator_address = object.operator_address ?? "";
    message.owner_address = object.owner_address ?? "";
    message.bucket_name = object.bucket_name ?? "";
    message.id = object.id ?? "";
    message.primary_sp_address = object.primary_sp_address ?? "";
    return message;
  }

};

function createBaseEventUpdateBucketInfo(): EventUpdateBucketInfo {
  return {
    operator_address: "",
    bucket_name: "",
    id: "",
    read_quota_before: Long.UZERO,
    read_quota_after: Long.UZERO,
    payment_address_before: "",
    payment_address_after: ""
  };
}

export const EventUpdateBucketInfo = {
  encode(message: EventUpdateBucketInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.operator_address !== "") {
      writer.uint32(10).string(message.operator_address);
    }

    if (message.bucket_name !== "") {
      writer.uint32(18).string(message.bucket_name);
    }

    if (message.id !== "") {
      writer.uint32(26).string(message.id);
    }

    if (!message.read_quota_before.isZero()) {
      writer.uint32(32).uint64(message.read_quota_before);
    }

    if (!message.read_quota_after.isZero()) {
      writer.uint32(40).uint64(message.read_quota_after);
    }

    if (message.payment_address_before !== "") {
      writer.uint32(50).string(message.payment_address_before);
    }

    if (message.payment_address_after !== "") {
      writer.uint32(58).string(message.payment_address_after);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventUpdateBucketInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventUpdateBucketInfo();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.operator_address = reader.string();
          break;

        case 2:
          message.bucket_name = reader.string();
          break;

        case 3:
          message.id = reader.string();
          break;

        case 4:
          message.read_quota_before = (reader.uint64() as Long);
          break;

        case 5:
          message.read_quota_after = (reader.uint64() as Long);
          break;

        case 6:
          message.payment_address_before = reader.string();
          break;

        case 7:
          message.payment_address_after = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): EventUpdateBucketInfo {
    return {
      operator_address: isSet(object.operator_address) ? String(object.operator_address) : "",
      bucket_name: isSet(object.bucket_name) ? String(object.bucket_name) : "",
      id: isSet(object.id) ? String(object.id) : "",
      read_quota_before: isSet(object.read_quota_before) ? Long.fromValue(object.read_quota_before) : Long.UZERO,
      read_quota_after: isSet(object.read_quota_after) ? Long.fromValue(object.read_quota_after) : Long.UZERO,
      payment_address_before: isSet(object.payment_address_before) ? String(object.payment_address_before) : "",
      payment_address_after: isSet(object.payment_address_after) ? String(object.payment_address_after) : ""
    };
  },

  toJSON(message: EventUpdateBucketInfo): unknown {
    const obj: any = {};
    message.operator_address !== undefined && (obj.operator_address = message.operator_address);
    message.bucket_name !== undefined && (obj.bucket_name = message.bucket_name);
    message.id !== undefined && (obj.id = message.id);
    message.read_quota_before !== undefined && (obj.read_quota_before = (message.read_quota_before || Long.UZERO).toString());
    message.read_quota_after !== undefined && (obj.read_quota_after = (message.read_quota_after || Long.UZERO).toString());
    message.payment_address_before !== undefined && (obj.payment_address_before = message.payment_address_before);
    message.payment_address_after !== undefined && (obj.payment_address_after = message.payment_address_after);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EventUpdateBucketInfo>, I>>(object: I): EventUpdateBucketInfo {
    const message = createBaseEventUpdateBucketInfo();
    message.operator_address = object.operator_address ?? "";
    message.bucket_name = object.bucket_name ?? "";
    message.id = object.id ?? "";
    message.read_quota_before = object.read_quota_before !== undefined && object.read_quota_before !== null ? Long.fromValue(object.read_quota_before) : Long.UZERO;
    message.read_quota_after = object.read_quota_after !== undefined && object.read_quota_after !== null ? Long.fromValue(object.read_quota_after) : Long.UZERO;
    message.payment_address_before = object.payment_address_before ?? "";
    message.payment_address_after = object.payment_address_after ?? "";
    return message;
  }

};

function createBaseEventCreateObject(): EventCreateObject {
  return {
    creator_address: "",
    owner_address: "",
    bucket_name: "",
    object_name: "",
    bucket_id: "",
    object_id: "",
    primary_sp_address: "",
    payload_size: Long.UZERO,
    is_public: false,
    content_type: "",
    create_at: Long.ZERO,
    status: 0,
    redundancy_type: 0,
    source_type: 0,
    checksums: []
  };
}

export const EventCreateObject = {
  encode(message: EventCreateObject, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.creator_address !== "") {
      writer.uint32(10).string(message.creator_address);
    }

    if (message.owner_address !== "") {
      writer.uint32(18).string(message.owner_address);
    }

    if (message.bucket_name !== "") {
      writer.uint32(26).string(message.bucket_name);
    }

    if (message.object_name !== "") {
      writer.uint32(34).string(message.object_name);
    }

    if (message.bucket_id !== "") {
      writer.uint32(50).string(message.bucket_id);
    }

    if (message.object_id !== "") {
      writer.uint32(58).string(message.object_id);
    }

    if (message.primary_sp_address !== "") {
      writer.uint32(66).string(message.primary_sp_address);
    }

    if (!message.payload_size.isZero()) {
      writer.uint32(72).uint64(message.payload_size);
    }

    if (message.is_public === true) {
      writer.uint32(80).bool(message.is_public);
    }

    if (message.content_type !== "") {
      writer.uint32(90).string(message.content_type);
    }

    if (!message.create_at.isZero()) {
      writer.uint32(96).int64(message.create_at);
    }

    if (message.status !== 0) {
      writer.uint32(104).int32(message.status);
    }

    if (message.redundancy_type !== 0) {
      writer.uint32(112).int32(message.redundancy_type);
    }

    if (message.source_type !== 0) {
      writer.uint32(120).int32(message.source_type);
    }

    for (const v of message.checksums) {
      writer.uint32(130).bytes(v!);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventCreateObject {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventCreateObject();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.creator_address = reader.string();
          break;

        case 2:
          message.owner_address = reader.string();
          break;

        case 3:
          message.bucket_name = reader.string();
          break;

        case 4:
          message.object_name = reader.string();
          break;

        case 6:
          message.bucket_id = reader.string();
          break;

        case 7:
          message.object_id = reader.string();
          break;

        case 8:
          message.primary_sp_address = reader.string();
          break;

        case 9:
          message.payload_size = (reader.uint64() as Long);
          break;

        case 10:
          message.is_public = reader.bool();
          break;

        case 11:
          message.content_type = reader.string();
          break;

        case 12:
          message.create_at = (reader.int64() as Long);
          break;

        case 13:
          message.status = (reader.int32() as any);
          break;

        case 14:
          message.redundancy_type = (reader.int32() as any);
          break;

        case 15:
          message.source_type = (reader.int32() as any);
          break;

        case 16:
          message.checksums.push(reader.bytes());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): EventCreateObject {
    return {
      creator_address: isSet(object.creator_address) ? String(object.creator_address) : "",
      owner_address: isSet(object.owner_address) ? String(object.owner_address) : "",
      bucket_name: isSet(object.bucket_name) ? String(object.bucket_name) : "",
      object_name: isSet(object.object_name) ? String(object.object_name) : "",
      bucket_id: isSet(object.bucket_id) ? String(object.bucket_id) : "",
      object_id: isSet(object.object_id) ? String(object.object_id) : "",
      primary_sp_address: isSet(object.primary_sp_address) ? String(object.primary_sp_address) : "",
      payload_size: isSet(object.payload_size) ? Long.fromValue(object.payload_size) : Long.UZERO,
      is_public: isSet(object.is_public) ? Boolean(object.is_public) : false,
      content_type: isSet(object.content_type) ? String(object.content_type) : "",
      create_at: isSet(object.create_at) ? Long.fromValue(object.create_at) : Long.ZERO,
      status: isSet(object.status) ? objectStatusFromJSON(object.status) : 0,
      redundancy_type: isSet(object.redundancy_type) ? redundancyTypeFromJSON(object.redundancy_type) : 0,
      source_type: isSet(object.source_type) ? sourceTypeFromJSON(object.source_type) : 0,
      checksums: Array.isArray(object?.checksums) ? object.checksums.map((e: any) => bytesFromBase64(e)) : []
    };
  },

  toJSON(message: EventCreateObject): unknown {
    const obj: any = {};
    message.creator_address !== undefined && (obj.creator_address = message.creator_address);
    message.owner_address !== undefined && (obj.owner_address = message.owner_address);
    message.bucket_name !== undefined && (obj.bucket_name = message.bucket_name);
    message.object_name !== undefined && (obj.object_name = message.object_name);
    message.bucket_id !== undefined && (obj.bucket_id = message.bucket_id);
    message.object_id !== undefined && (obj.object_id = message.object_id);
    message.primary_sp_address !== undefined && (obj.primary_sp_address = message.primary_sp_address);
    message.payload_size !== undefined && (obj.payload_size = (message.payload_size || Long.UZERO).toString());
    message.is_public !== undefined && (obj.is_public = message.is_public);
    message.content_type !== undefined && (obj.content_type = message.content_type);
    message.create_at !== undefined && (obj.create_at = (message.create_at || Long.ZERO).toString());
    message.status !== undefined && (obj.status = objectStatusToJSON(message.status));
    message.redundancy_type !== undefined && (obj.redundancy_type = redundancyTypeToJSON(message.redundancy_type));
    message.source_type !== undefined && (obj.source_type = sourceTypeToJSON(message.source_type));

    if (message.checksums) {
      obj.checksums = message.checksums.map(e => base64FromBytes(e !== undefined ? e : new Uint8Array()));
    } else {
      obj.checksums = [];
    }

    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EventCreateObject>, I>>(object: I): EventCreateObject {
    const message = createBaseEventCreateObject();
    message.creator_address = object.creator_address ?? "";
    message.owner_address = object.owner_address ?? "";
    message.bucket_name = object.bucket_name ?? "";
    message.object_name = object.object_name ?? "";
    message.bucket_id = object.bucket_id ?? "";
    message.object_id = object.object_id ?? "";
    message.primary_sp_address = object.primary_sp_address ?? "";
    message.payload_size = object.payload_size !== undefined && object.payload_size !== null ? Long.fromValue(object.payload_size) : Long.UZERO;
    message.is_public = object.is_public ?? false;
    message.content_type = object.content_type ?? "";
    message.create_at = object.create_at !== undefined && object.create_at !== null ? Long.fromValue(object.create_at) : Long.ZERO;
    message.status = object.status ?? 0;
    message.redundancy_type = object.redundancy_type ?? 0;
    message.source_type = object.source_type ?? 0;
    message.checksums = object.checksums?.map(e => e) || [];
    return message;
  }

};

function createBaseEventCancelCreateObject(): EventCancelCreateObject {
  return {
    operator_address: "",
    bucket_name: "",
    object_name: "",
    primary_sp_address: "",
    id: ""
  };
}

export const EventCancelCreateObject = {
  encode(message: EventCancelCreateObject, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.operator_address !== "") {
      writer.uint32(10).string(message.operator_address);
    }

    if (message.bucket_name !== "") {
      writer.uint32(18).string(message.bucket_name);
    }

    if (message.object_name !== "") {
      writer.uint32(26).string(message.object_name);
    }

    if (message.primary_sp_address !== "") {
      writer.uint32(34).string(message.primary_sp_address);
    }

    if (message.id !== "") {
      writer.uint32(50).string(message.id);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventCancelCreateObject {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventCancelCreateObject();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.operator_address = reader.string();
          break;

        case 2:
          message.bucket_name = reader.string();
          break;

        case 3:
          message.object_name = reader.string();
          break;

        case 4:
          message.primary_sp_address = reader.string();
          break;

        case 6:
          message.id = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): EventCancelCreateObject {
    return {
      operator_address: isSet(object.operator_address) ? String(object.operator_address) : "",
      bucket_name: isSet(object.bucket_name) ? String(object.bucket_name) : "",
      object_name: isSet(object.object_name) ? String(object.object_name) : "",
      primary_sp_address: isSet(object.primary_sp_address) ? String(object.primary_sp_address) : "",
      id: isSet(object.id) ? String(object.id) : ""
    };
  },

  toJSON(message: EventCancelCreateObject): unknown {
    const obj: any = {};
    message.operator_address !== undefined && (obj.operator_address = message.operator_address);
    message.bucket_name !== undefined && (obj.bucket_name = message.bucket_name);
    message.object_name !== undefined && (obj.object_name = message.object_name);
    message.primary_sp_address !== undefined && (obj.primary_sp_address = message.primary_sp_address);
    message.id !== undefined && (obj.id = message.id);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EventCancelCreateObject>, I>>(object: I): EventCancelCreateObject {
    const message = createBaseEventCancelCreateObject();
    message.operator_address = object.operator_address ?? "";
    message.bucket_name = object.bucket_name ?? "";
    message.object_name = object.object_name ?? "";
    message.primary_sp_address = object.primary_sp_address ?? "";
    message.id = object.id ?? "";
    return message;
  }

};

function createBaseEventSealObject(): EventSealObject {
  return {
    operator_address: "",
    bucket_name: "",
    object_name: "",
    id: "",
    status: 0,
    secondary_sp_address: []
  };
}

export const EventSealObject = {
  encode(message: EventSealObject, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.operator_address !== "") {
      writer.uint32(10).string(message.operator_address);
    }

    if (message.bucket_name !== "") {
      writer.uint32(18).string(message.bucket_name);
    }

    if (message.object_name !== "") {
      writer.uint32(26).string(message.object_name);
    }

    if (message.id !== "") {
      writer.uint32(42).string(message.id);
    }

    if (message.status !== 0) {
      writer.uint32(48).int32(message.status);
    }

    for (const v of message.secondary_sp_address) {
      writer.uint32(58).string(v!);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventSealObject {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventSealObject();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.operator_address = reader.string();
          break;

        case 2:
          message.bucket_name = reader.string();
          break;

        case 3:
          message.object_name = reader.string();
          break;

        case 5:
          message.id = reader.string();
          break;

        case 6:
          message.status = (reader.int32() as any);
          break;

        case 7:
          message.secondary_sp_address.push(reader.string());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): EventSealObject {
    return {
      operator_address: isSet(object.operator_address) ? String(object.operator_address) : "",
      bucket_name: isSet(object.bucket_name) ? String(object.bucket_name) : "",
      object_name: isSet(object.object_name) ? String(object.object_name) : "",
      id: isSet(object.id) ? String(object.id) : "",
      status: isSet(object.status) ? objectStatusFromJSON(object.status) : 0,
      secondary_sp_address: Array.isArray(object?.secondary_sp_address) ? object.secondary_sp_address.map((e: any) => String(e)) : []
    };
  },

  toJSON(message: EventSealObject): unknown {
    const obj: any = {};
    message.operator_address !== undefined && (obj.operator_address = message.operator_address);
    message.bucket_name !== undefined && (obj.bucket_name = message.bucket_name);
    message.object_name !== undefined && (obj.object_name = message.object_name);
    message.id !== undefined && (obj.id = message.id);
    message.status !== undefined && (obj.status = objectStatusToJSON(message.status));

    if (message.secondary_sp_address) {
      obj.secondary_sp_address = message.secondary_sp_address.map(e => e);
    } else {
      obj.secondary_sp_address = [];
    }

    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EventSealObject>, I>>(object: I): EventSealObject {
    const message = createBaseEventSealObject();
    message.operator_address = object.operator_address ?? "";
    message.bucket_name = object.bucket_name ?? "";
    message.object_name = object.object_name ?? "";
    message.id = object.id ?? "";
    message.status = object.status ?? 0;
    message.secondary_sp_address = object.secondary_sp_address?.map(e => e) || [];
    return message;
  }

};

function createBaseEventCopyObject(): EventCopyObject {
  return {
    operator_address: "",
    src_bucket_name: "",
    src_object_name: "",
    dst_bucket_name: "",
    dst_object_name: "",
    src_object_id: "",
    dst_object_id: ""
  };
}

export const EventCopyObject = {
  encode(message: EventCopyObject, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.operator_address !== "") {
      writer.uint32(10).string(message.operator_address);
    }

    if (message.src_bucket_name !== "") {
      writer.uint32(18).string(message.src_bucket_name);
    }

    if (message.src_object_name !== "") {
      writer.uint32(26).string(message.src_object_name);
    }

    if (message.dst_bucket_name !== "") {
      writer.uint32(34).string(message.dst_bucket_name);
    }

    if (message.dst_object_name !== "") {
      writer.uint32(42).string(message.dst_object_name);
    }

    if (message.src_object_id !== "") {
      writer.uint32(50).string(message.src_object_id);
    }

    if (message.dst_object_id !== "") {
      writer.uint32(58).string(message.dst_object_id);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventCopyObject {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventCopyObject();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.operator_address = reader.string();
          break;

        case 2:
          message.src_bucket_name = reader.string();
          break;

        case 3:
          message.src_object_name = reader.string();
          break;

        case 4:
          message.dst_bucket_name = reader.string();
          break;

        case 5:
          message.dst_object_name = reader.string();
          break;

        case 6:
          message.src_object_id = reader.string();
          break;

        case 7:
          message.dst_object_id = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): EventCopyObject {
    return {
      operator_address: isSet(object.operator_address) ? String(object.operator_address) : "",
      src_bucket_name: isSet(object.src_bucket_name) ? String(object.src_bucket_name) : "",
      src_object_name: isSet(object.src_object_name) ? String(object.src_object_name) : "",
      dst_bucket_name: isSet(object.dst_bucket_name) ? String(object.dst_bucket_name) : "",
      dst_object_name: isSet(object.dst_object_name) ? String(object.dst_object_name) : "",
      src_object_id: isSet(object.src_object_id) ? String(object.src_object_id) : "",
      dst_object_id: isSet(object.dst_object_id) ? String(object.dst_object_id) : ""
    };
  },

  toJSON(message: EventCopyObject): unknown {
    const obj: any = {};
    message.operator_address !== undefined && (obj.operator_address = message.operator_address);
    message.src_bucket_name !== undefined && (obj.src_bucket_name = message.src_bucket_name);
    message.src_object_name !== undefined && (obj.src_object_name = message.src_object_name);
    message.dst_bucket_name !== undefined && (obj.dst_bucket_name = message.dst_bucket_name);
    message.dst_object_name !== undefined && (obj.dst_object_name = message.dst_object_name);
    message.src_object_id !== undefined && (obj.src_object_id = message.src_object_id);
    message.dst_object_id !== undefined && (obj.dst_object_id = message.dst_object_id);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EventCopyObject>, I>>(object: I): EventCopyObject {
    const message = createBaseEventCopyObject();
    message.operator_address = object.operator_address ?? "";
    message.src_bucket_name = object.src_bucket_name ?? "";
    message.src_object_name = object.src_object_name ?? "";
    message.dst_bucket_name = object.dst_bucket_name ?? "";
    message.dst_object_name = object.dst_object_name ?? "";
    message.src_object_id = object.src_object_id ?? "";
    message.dst_object_id = object.dst_object_id ?? "";
    return message;
  }

};

function createBaseEventDeleteObject(): EventDeleteObject {
  return {
    operator_address: "",
    bucket_name: "",
    object_name: "",
    id: "",
    primary_sp_address: "",
    secondary_sp_addresses: []
  };
}

export const EventDeleteObject = {
  encode(message: EventDeleteObject, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.operator_address !== "") {
      writer.uint32(10).string(message.operator_address);
    }

    if (message.bucket_name !== "") {
      writer.uint32(18).string(message.bucket_name);
    }

    if (message.object_name !== "") {
      writer.uint32(26).string(message.object_name);
    }

    if (message.id !== "") {
      writer.uint32(34).string(message.id);
    }

    if (message.primary_sp_address !== "") {
      writer.uint32(42).string(message.primary_sp_address);
    }

    for (const v of message.secondary_sp_addresses) {
      writer.uint32(50).string(v!);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventDeleteObject {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventDeleteObject();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.operator_address = reader.string();
          break;

        case 2:
          message.bucket_name = reader.string();
          break;

        case 3:
          message.object_name = reader.string();
          break;

        case 4:
          message.id = reader.string();
          break;

        case 5:
          message.primary_sp_address = reader.string();
          break;

        case 6:
          message.secondary_sp_addresses.push(reader.string());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): EventDeleteObject {
    return {
      operator_address: isSet(object.operator_address) ? String(object.operator_address) : "",
      bucket_name: isSet(object.bucket_name) ? String(object.bucket_name) : "",
      object_name: isSet(object.object_name) ? String(object.object_name) : "",
      id: isSet(object.id) ? String(object.id) : "",
      primary_sp_address: isSet(object.primary_sp_address) ? String(object.primary_sp_address) : "",
      secondary_sp_addresses: Array.isArray(object?.secondary_sp_addresses) ? object.secondary_sp_addresses.map((e: any) => String(e)) : []
    };
  },

  toJSON(message: EventDeleteObject): unknown {
    const obj: any = {};
    message.operator_address !== undefined && (obj.operator_address = message.operator_address);
    message.bucket_name !== undefined && (obj.bucket_name = message.bucket_name);
    message.object_name !== undefined && (obj.object_name = message.object_name);
    message.id !== undefined && (obj.id = message.id);
    message.primary_sp_address !== undefined && (obj.primary_sp_address = message.primary_sp_address);

    if (message.secondary_sp_addresses) {
      obj.secondary_sp_addresses = message.secondary_sp_addresses.map(e => e);
    } else {
      obj.secondary_sp_addresses = [];
    }

    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EventDeleteObject>, I>>(object: I): EventDeleteObject {
    const message = createBaseEventDeleteObject();
    message.operator_address = object.operator_address ?? "";
    message.bucket_name = object.bucket_name ?? "";
    message.object_name = object.object_name ?? "";
    message.id = object.id ?? "";
    message.primary_sp_address = object.primary_sp_address ?? "";
    message.secondary_sp_addresses = object.secondary_sp_addresses?.map(e => e) || [];
    return message;
  }

};

function createBaseEventRejectSealObject(): EventRejectSealObject {
  return {
    operator_address: "",
    bucket_name: "",
    object_name: "",
    id: ""
  };
}

export const EventRejectSealObject = {
  encode(message: EventRejectSealObject, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.operator_address !== "") {
      writer.uint32(10).string(message.operator_address);
    }

    if (message.bucket_name !== "") {
      writer.uint32(18).string(message.bucket_name);
    }

    if (message.object_name !== "") {
      writer.uint32(26).string(message.object_name);
    }

    if (message.id !== "") {
      writer.uint32(34).string(message.id);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventRejectSealObject {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventRejectSealObject();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.operator_address = reader.string();
          break;

        case 2:
          message.bucket_name = reader.string();
          break;

        case 3:
          message.object_name = reader.string();
          break;

        case 4:
          message.id = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): EventRejectSealObject {
    return {
      operator_address: isSet(object.operator_address) ? String(object.operator_address) : "",
      bucket_name: isSet(object.bucket_name) ? String(object.bucket_name) : "",
      object_name: isSet(object.object_name) ? String(object.object_name) : "",
      id: isSet(object.id) ? String(object.id) : ""
    };
  },

  toJSON(message: EventRejectSealObject): unknown {
    const obj: any = {};
    message.operator_address !== undefined && (obj.operator_address = message.operator_address);
    message.bucket_name !== undefined && (obj.bucket_name = message.bucket_name);
    message.object_name !== undefined && (obj.object_name = message.object_name);
    message.id !== undefined && (obj.id = message.id);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EventRejectSealObject>, I>>(object: I): EventRejectSealObject {
    const message = createBaseEventRejectSealObject();
    message.operator_address = object.operator_address ?? "";
    message.bucket_name = object.bucket_name ?? "";
    message.object_name = object.object_name ?? "";
    message.id = object.id ?? "";
    return message;
  }

};

function createBaseEventCreateGroup(): EventCreateGroup {
  return {
    owner_address: "",
    group_name: "",
    id: "",
    source_type: 0,
    members: []
  };
}

export const EventCreateGroup = {
  encode(message: EventCreateGroup, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.owner_address !== "") {
      writer.uint32(10).string(message.owner_address);
    }

    if (message.group_name !== "") {
      writer.uint32(18).string(message.group_name);
    }

    if (message.id !== "") {
      writer.uint32(26).string(message.id);
    }

    if (message.source_type !== 0) {
      writer.uint32(32).int32(message.source_type);
    }

    for (const v of message.members) {
      writer.uint32(42).string(v!);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventCreateGroup {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventCreateGroup();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.owner_address = reader.string();
          break;

        case 2:
          message.group_name = reader.string();
          break;

        case 3:
          message.id = reader.string();
          break;

        case 4:
          message.source_type = (reader.int32() as any);
          break;

        case 5:
          message.members.push(reader.string());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): EventCreateGroup {
    return {
      owner_address: isSet(object.owner_address) ? String(object.owner_address) : "",
      group_name: isSet(object.group_name) ? String(object.group_name) : "",
      id: isSet(object.id) ? String(object.id) : "",
      source_type: isSet(object.source_type) ? sourceTypeFromJSON(object.source_type) : 0,
      members: Array.isArray(object?.members) ? object.members.map((e: any) => String(e)) : []
    };
  },

  toJSON(message: EventCreateGroup): unknown {
    const obj: any = {};
    message.owner_address !== undefined && (obj.owner_address = message.owner_address);
    message.group_name !== undefined && (obj.group_name = message.group_name);
    message.id !== undefined && (obj.id = message.id);
    message.source_type !== undefined && (obj.source_type = sourceTypeToJSON(message.source_type));

    if (message.members) {
      obj.members = message.members.map(e => e);
    } else {
      obj.members = [];
    }

    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EventCreateGroup>, I>>(object: I): EventCreateGroup {
    const message = createBaseEventCreateGroup();
    message.owner_address = object.owner_address ?? "";
    message.group_name = object.group_name ?? "";
    message.id = object.id ?? "";
    message.source_type = object.source_type ?? 0;
    message.members = object.members?.map(e => e) || [];
    return message;
  }

};

function createBaseEventDeleteGroup(): EventDeleteGroup {
  return {
    owner_address: "",
    group_name: "",
    id: ""
  };
}

export const EventDeleteGroup = {
  encode(message: EventDeleteGroup, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.owner_address !== "") {
      writer.uint32(18).string(message.owner_address);
    }

    if (message.group_name !== "") {
      writer.uint32(26).string(message.group_name);
    }

    if (message.id !== "") {
      writer.uint32(34).string(message.id);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventDeleteGroup {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventDeleteGroup();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 2:
          message.owner_address = reader.string();
          break;

        case 3:
          message.group_name = reader.string();
          break;

        case 4:
          message.id = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): EventDeleteGroup {
    return {
      owner_address: isSet(object.owner_address) ? String(object.owner_address) : "",
      group_name: isSet(object.group_name) ? String(object.group_name) : "",
      id: isSet(object.id) ? String(object.id) : ""
    };
  },

  toJSON(message: EventDeleteGroup): unknown {
    const obj: any = {};
    message.owner_address !== undefined && (obj.owner_address = message.owner_address);
    message.group_name !== undefined && (obj.group_name = message.group_name);
    message.id !== undefined && (obj.id = message.id);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EventDeleteGroup>, I>>(object: I): EventDeleteGroup {
    const message = createBaseEventDeleteGroup();
    message.owner_address = object.owner_address ?? "";
    message.group_name = object.group_name ?? "";
    message.id = object.id ?? "";
    return message;
  }

};

function createBaseEventLeaveGroup(): EventLeaveGroup {
  return {
    member_address: "",
    owner_address: "",
    group_name: "",
    id: ""
  };
}

export const EventLeaveGroup = {
  encode(message: EventLeaveGroup, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.member_address !== "") {
      writer.uint32(10).string(message.member_address);
    }

    if (message.owner_address !== "") {
      writer.uint32(18).string(message.owner_address);
    }

    if (message.group_name !== "") {
      writer.uint32(26).string(message.group_name);
    }

    if (message.id !== "") {
      writer.uint32(34).string(message.id);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventLeaveGroup {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventLeaveGroup();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.member_address = reader.string();
          break;

        case 2:
          message.owner_address = reader.string();
          break;

        case 3:
          message.group_name = reader.string();
          break;

        case 4:
          message.id = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): EventLeaveGroup {
    return {
      member_address: isSet(object.member_address) ? String(object.member_address) : "",
      owner_address: isSet(object.owner_address) ? String(object.owner_address) : "",
      group_name: isSet(object.group_name) ? String(object.group_name) : "",
      id: isSet(object.id) ? String(object.id) : ""
    };
  },

  toJSON(message: EventLeaveGroup): unknown {
    const obj: any = {};
    message.member_address !== undefined && (obj.member_address = message.member_address);
    message.owner_address !== undefined && (obj.owner_address = message.owner_address);
    message.group_name !== undefined && (obj.group_name = message.group_name);
    message.id !== undefined && (obj.id = message.id);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EventLeaveGroup>, I>>(object: I): EventLeaveGroup {
    const message = createBaseEventLeaveGroup();
    message.member_address = object.member_address ?? "";
    message.owner_address = object.owner_address ?? "";
    message.group_name = object.group_name ?? "";
    message.id = object.id ?? "";
    return message;
  }

};

function createBaseEventUpdateGroupMember(): EventUpdateGroupMember {
  return {
    operator_address: "",
    owner_address: "",
    group_name: "",
    id: "",
    members_to_add: [],
    members_to_delete: []
  };
}

export const EventUpdateGroupMember = {
  encode(message: EventUpdateGroupMember, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.operator_address !== "") {
      writer.uint32(10).string(message.operator_address);
    }

    if (message.owner_address !== "") {
      writer.uint32(18).string(message.owner_address);
    }

    if (message.group_name !== "") {
      writer.uint32(26).string(message.group_name);
    }

    if (message.id !== "") {
      writer.uint32(34).string(message.id);
    }

    for (const v of message.members_to_add) {
      writer.uint32(42).string(v!);
    }

    for (const v of message.members_to_delete) {
      writer.uint32(50).string(v!);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventUpdateGroupMember {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventUpdateGroupMember();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.operator_address = reader.string();
          break;

        case 2:
          message.owner_address = reader.string();
          break;

        case 3:
          message.group_name = reader.string();
          break;

        case 4:
          message.id = reader.string();
          break;

        case 5:
          message.members_to_add.push(reader.string());
          break;

        case 6:
          message.members_to_delete.push(reader.string());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): EventUpdateGroupMember {
    return {
      operator_address: isSet(object.operator_address) ? String(object.operator_address) : "",
      owner_address: isSet(object.owner_address) ? String(object.owner_address) : "",
      group_name: isSet(object.group_name) ? String(object.group_name) : "",
      id: isSet(object.id) ? String(object.id) : "",
      members_to_add: Array.isArray(object?.members_to_add) ? object.members_to_add.map((e: any) => String(e)) : [],
      members_to_delete: Array.isArray(object?.members_to_delete) ? object.members_to_delete.map((e: any) => String(e)) : []
    };
  },

  toJSON(message: EventUpdateGroupMember): unknown {
    const obj: any = {};
    message.operator_address !== undefined && (obj.operator_address = message.operator_address);
    message.owner_address !== undefined && (obj.owner_address = message.owner_address);
    message.group_name !== undefined && (obj.group_name = message.group_name);
    message.id !== undefined && (obj.id = message.id);

    if (message.members_to_add) {
      obj.members_to_add = message.members_to_add.map(e => e);
    } else {
      obj.members_to_add = [];
    }

    if (message.members_to_delete) {
      obj.members_to_delete = message.members_to_delete.map(e => e);
    } else {
      obj.members_to_delete = [];
    }

    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EventUpdateGroupMember>, I>>(object: I): EventUpdateGroupMember {
    const message = createBaseEventUpdateGroupMember();
    message.operator_address = object.operator_address ?? "";
    message.owner_address = object.owner_address ?? "";
    message.group_name = object.group_name ?? "";
    message.id = object.id ?? "";
    message.members_to_add = object.members_to_add?.map(e => e) || [];
    message.members_to_delete = object.members_to_delete?.map(e => e) || [];
    return message;
  }

};