/* eslint-disable */
import { SourceType, ReadQuota, ObjectStatus, RedundancyType, sourceTypeFromJSON, readQuotaFromJSON, sourceTypeToJSON, readQuotaToJSON, objectStatusFromJSON, redundancyTypeFromJSON, objectStatusToJSON, redundancyTypeToJSON } from "./common";
import { Long, isSet, DeepPartial, Exact, bytesFromBase64, base64FromBytes } from "../../helpers";
import * as _m0 from "protobufjs/minimal";
export const protobufPackage = "bnbchain.greenfield.storage";
/** EventCreateBucket is emitted on MsgCreateBucket */

export interface EventCreateBucket {
  /** owner_address define the account address of bucket owner */
  ownerAddress: string;
  /** bucket_name is a globally unique name of bucket */

  bucketName: string;
  /** is_public define the highest permissions for bucket. When the bucket is public, everyone can get the object in it. */

  isPublic: boolean;
  /** create_at define the block number when the bucket has been created */

  createAt: Long;
  /** id is the unique u256 for bucket. Not global, only unique in buckets. */

  id: string;
  /** source_type define the source of the bucket. CrossChain or Greenfield origin */

  sourceType: SourceType;
  /** read_quota defines the traffic quota for read */

  readQuota: ReadQuota;
  /** payment_address is the address of the payment account */

  paymentAddress: string;
  /** primary_sp_address is the operator address of the primary sp. */

  primarySpAddress: string;
}
/** EventDeleteBucket is emitted on MsgDeleteBucket */

export interface EventDeleteBucket {
  /** operator_address define the account address of operator who delete the bucket */
  operatorAddress: string;
  /** owner_address define the account address of the bucket owner */

  ownerAddress: string;
  /** bucket_name define the name of the deleted bucket */

  bucketName: string;
  /** id define an u256 id for bucket */

  id: string;
  /** primary_sp_address define the account address of primary sp */

  primarySpAddress: string;
}
/** EventUpdateBucketInfo is emitted on MsgUpdateBucketInfo */

export interface EventUpdateBucketInfo {
  /** operator_address define the account address of operator who update the bucket */
  operatorAddress: string;
  /** bucket_name define the name of the bucket */

  bucketName: string;
  /** id define an u256 id for bucket */

  id: string;
  /** read_quota_before define the read quota before updated */

  readQuotaBefore: ReadQuota;
  /** read_quota_after define the read quota after updated */

  readQuotaAfter: ReadQuota;
  /** payment_address_before define the payment address before updated */

  paymentAddressBefore: string;
  /** payment_address_after define the payment address after updated */

  paymentAddressAfter: string;
}
/** EventCreateObject is emitted on MsgCreateObject */

export interface EventCreateObject {
  /** creator_address define the account address of msg creator */
  creatorAddress: string;
  /** owner_address define the account address of object owner */

  ownerAddress: string;
  /** bucket_name define the name of bucket */

  bucketName: string;
  /** object_name define the name of object */

  objectName: string;
  /** id define an u256 id for object */

  id: string;
  /** primary_sp_address define the account address of primary sp */

  primarySpAddress: string;
  /** payload_size define the size of payload data which you want upload */

  payloadSize: Long;
  /** is_public define the highest permission of object. */

  isPublic: boolean;
  /** content_type define the content type of the payload data */

  contentType: string;
  /** create_at define the block number when the object created */

  createAt: Long;
  /** status define the status of the object. INIT or IN_SERVICE or others */

  status: ObjectStatus;
  /** redundancy_type define the type of redundancy. Replication or EC */

  redundancyType: RedundancyType;
  /** source_type define the source of the object.  CrossChain or Greenfield origin */

  sourceType: SourceType;
  /** checksums define the total checksums of the object which generated by redundancy */

  checksums: Uint8Array[];
}
/** EventSealObject is emitted on MsgSealObject */

export interface EventCancelCreateObject {
  /** operator_address define the account address of operator who cancel create object */
  operatorAddress: string;
  /** bucket_name define the name of the bucket */

  bucketName: string;
  /** object_name define the name of the object */

  objectName: string;
  /** primary_sp_address define the operator account address of the sp */

  primarySpAddress: string;
  /** id define an u256 id for object */

  id: string;
}
/** EventSealObject is emitted on MsgSealObject */

export interface EventSealObject {
  /** operator_address define the account address of operator who seal object */
  operatorAddress: string;
  /** bucket_name define the name of the bucket */

  bucketName: string;
  /** object_name define the name of the object */

  objectName: string;
  /** id define an u256 id for object */

  id: string;
  /** status define the status of the object. INIT or IN_SERVICE or others */

  status: ObjectStatus;
  /** secondary_sp_address define all the operator address of the secondary sps */

  secondarySpAddress: string[];
}
/** EventCopyObject is emitted on MsgCopyObject */

export interface EventCopyObject {
  /** operator_address define the account address of operator who copy the object */
  operatorAddress: string;
  /** src_bucket_name define the name of the src bucket */

  srcBucketName: string;
  /** src_object_name define the name of the src object */

  srcObjectName: string;
  /** dst_bucket_name define the name of the dst bucket */

  dstBucketName: string;
  /** dst_object_name define the name of the dst object */

  dstObjectName: string;
  /** src_object_id define the u256 id for src object */

  srcObjectId: string;
  /** dst_object_id define the u256 id for dst object */

  dstObjectId: string;
}
/** EventDeleteObject is emitted on MsgDeleteObject */

export interface EventDeleteObject {
  /** operator_address define the account address of operator who delete the object */
  operatorAddress: string;
  /** bucket_name define the name of the bucket */

  bucketName: string;
  /** object_name define the name of the object */

  objectName: string;
  /** id define an u256 id for object */

  id: string;
  /** primary_sp_address define the operator account address of the sp */

  primarySpAddress: string;
  /** secondary_sp_address define all the operator address of the secondary sps */

  secondarySpAddresses: string[];
}
/** EventRejectSealObject is emitted on MsgRejectSealObject */

export interface EventRejectSealObject {
  /** operator_address define the account address of operator who reject seal object */
  operatorAddress: string;
  /** bucket_name define the name of the bucket */

  bucketName: string;
  /** object_name define the name of the object */

  objectName: string;
  /** id define an u256 id for object */

  id: string;
}
/** EventCreateGroup is emitted on MsgCreateGroup */

export interface EventCreateGroup {
  /** owner_address define the account address of group owner */
  ownerAddress: string;
  /** group_name define the name of the group */

  groupName: string;
  /** id define an u256 id for group */

  id: string;
  /** source_type define the source of the group. CrossChain or Greenfield origin */

  sourceType: SourceType;
  /** members define the all the address of the members. */

  members: string[];
}
/** EventDeleteGroup is emitted on MsgDeleteGroup */

export interface EventDeleteGroup {
  /** owner_address define the account address of group owner */
  ownerAddress: string;
  /** group_name define the name of the group */

  groupName: string;
  /** id define an u256 id for group */

  id: string;
}
/** EventLeaveGroup is emitted on MsgLeaveGroup */

export interface EventLeaveGroup {
  /** member_address define the address of the member who leave the group */
  memberAddress: string;
  /** owner_address define the account address of group owner */

  ownerAddress: string;
  /** group_name define the name of the group */

  groupName: string;
  /** id define an u256 id for group */

  id: string;
}
/** EventUpdateGroupMember is emitted on MsgUpdateGroupMember */

export interface EventUpdateGroupMember {
  /** operator_address define the account address of operator who update the group member */
  operatorAddress: string;
  /** owner_address define the account address of group owner */

  ownerAddress: string;
  /** group_name define the name of the group */

  groupName: string;
  /** id define an u256 id for group */

  id: string;
  /** members_to_add defines all the members to be added to the group */

  membersToAdd: string[];
  /** members_to_add defines all the members to be deleted from the group */

  membersToDelete: string[];
}

function createBaseEventCreateBucket(): EventCreateBucket {
  return {
    ownerAddress: "",
    bucketName: "",
    isPublic: false,
    createAt: Long.ZERO,
    id: "",
    sourceType: 0,
    readQuota: 0,
    paymentAddress: "",
    primarySpAddress: ""
  };
}

export const EventCreateBucket = {
  encode(message: EventCreateBucket, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ownerAddress !== "") {
      writer.uint32(10).string(message.ownerAddress);
    }

    if (message.bucketName !== "") {
      writer.uint32(18).string(message.bucketName);
    }

    if (message.isPublic === true) {
      writer.uint32(24).bool(message.isPublic);
    }

    if (!message.createAt.isZero()) {
      writer.uint32(32).int64(message.createAt);
    }

    if (message.id !== "") {
      writer.uint32(42).string(message.id);
    }

    if (message.sourceType !== 0) {
      writer.uint32(48).int32(message.sourceType);
    }

    if (message.readQuota !== 0) {
      writer.uint32(56).int32(message.readQuota);
    }

    if (message.paymentAddress !== "") {
      writer.uint32(66).string(message.paymentAddress);
    }

    if (message.primarySpAddress !== "") {
      writer.uint32(74).string(message.primarySpAddress);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventCreateBucket {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventCreateBucket();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.ownerAddress = reader.string();
          break;

        case 2:
          message.bucketName = reader.string();
          break;

        case 3:
          message.isPublic = reader.bool();
          break;

        case 4:
          message.createAt = (reader.int64() as Long);
          break;

        case 5:
          message.id = reader.string();
          break;

        case 6:
          message.sourceType = (reader.int32() as any);
          break;

        case 7:
          message.readQuota = (reader.int32() as any);
          break;

        case 8:
          message.paymentAddress = reader.string();
          break;

        case 9:
          message.primarySpAddress = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): EventCreateBucket {
    return {
      ownerAddress: isSet(object.ownerAddress) ? String(object.ownerAddress) : "",
      bucketName: isSet(object.bucketName) ? String(object.bucketName) : "",
      isPublic: isSet(object.isPublic) ? Boolean(object.isPublic) : false,
      createAt: isSet(object.createAt) ? Long.fromValue(object.createAt) : Long.ZERO,
      id: isSet(object.id) ? String(object.id) : "",
      sourceType: isSet(object.sourceType) ? sourceTypeFromJSON(object.sourceType) : 0,
      readQuota: isSet(object.readQuota) ? readQuotaFromJSON(object.readQuota) : 0,
      paymentAddress: isSet(object.paymentAddress) ? String(object.paymentAddress) : "",
      primarySpAddress: isSet(object.primarySpAddress) ? String(object.primarySpAddress) : ""
    };
  },

  toJSON(message: EventCreateBucket): unknown {
    const obj: any = {};
    message.ownerAddress !== undefined && (obj.ownerAddress = message.ownerAddress);
    message.bucketName !== undefined && (obj.bucketName = message.bucketName);
    message.isPublic !== undefined && (obj.isPublic = message.isPublic);
    message.createAt !== undefined && (obj.createAt = (message.createAt || Long.ZERO).toString());
    message.id !== undefined && (obj.id = message.id);
    message.sourceType !== undefined && (obj.sourceType = sourceTypeToJSON(message.sourceType));
    message.readQuota !== undefined && (obj.readQuota = readQuotaToJSON(message.readQuota));
    message.paymentAddress !== undefined && (obj.paymentAddress = message.paymentAddress);
    message.primarySpAddress !== undefined && (obj.primarySpAddress = message.primarySpAddress);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EventCreateBucket>, I>>(object: I): EventCreateBucket {
    const message = createBaseEventCreateBucket();
    message.ownerAddress = object.ownerAddress ?? "";
    message.bucketName = object.bucketName ?? "";
    message.isPublic = object.isPublic ?? false;
    message.createAt = object.createAt !== undefined && object.createAt !== null ? Long.fromValue(object.createAt) : Long.ZERO;
    message.id = object.id ?? "";
    message.sourceType = object.sourceType ?? 0;
    message.readQuota = object.readQuota ?? 0;
    message.paymentAddress = object.paymentAddress ?? "";
    message.primarySpAddress = object.primarySpAddress ?? "";
    return message;
  }

};

function createBaseEventDeleteBucket(): EventDeleteBucket {
  return {
    operatorAddress: "",
    ownerAddress: "",
    bucketName: "",
    id: "",
    primarySpAddress: ""
  };
}

export const EventDeleteBucket = {
  encode(message: EventDeleteBucket, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.operatorAddress !== "") {
      writer.uint32(10).string(message.operatorAddress);
    }

    if (message.ownerAddress !== "") {
      writer.uint32(18).string(message.ownerAddress);
    }

    if (message.bucketName !== "") {
      writer.uint32(26).string(message.bucketName);
    }

    if (message.id !== "") {
      writer.uint32(34).string(message.id);
    }

    if (message.primarySpAddress !== "") {
      writer.uint32(42).string(message.primarySpAddress);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventDeleteBucket {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventDeleteBucket();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.operatorAddress = reader.string();
          break;

        case 2:
          message.ownerAddress = reader.string();
          break;

        case 3:
          message.bucketName = reader.string();
          break;

        case 4:
          message.id = reader.string();
          break;

        case 5:
          message.primarySpAddress = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): EventDeleteBucket {
    return {
      operatorAddress: isSet(object.operatorAddress) ? String(object.operatorAddress) : "",
      ownerAddress: isSet(object.ownerAddress) ? String(object.ownerAddress) : "",
      bucketName: isSet(object.bucketName) ? String(object.bucketName) : "",
      id: isSet(object.id) ? String(object.id) : "",
      primarySpAddress: isSet(object.primarySpAddress) ? String(object.primarySpAddress) : ""
    };
  },

  toJSON(message: EventDeleteBucket): unknown {
    const obj: any = {};
    message.operatorAddress !== undefined && (obj.operatorAddress = message.operatorAddress);
    message.ownerAddress !== undefined && (obj.ownerAddress = message.ownerAddress);
    message.bucketName !== undefined && (obj.bucketName = message.bucketName);
    message.id !== undefined && (obj.id = message.id);
    message.primarySpAddress !== undefined && (obj.primarySpAddress = message.primarySpAddress);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EventDeleteBucket>, I>>(object: I): EventDeleteBucket {
    const message = createBaseEventDeleteBucket();
    message.operatorAddress = object.operatorAddress ?? "";
    message.ownerAddress = object.ownerAddress ?? "";
    message.bucketName = object.bucketName ?? "";
    message.id = object.id ?? "";
    message.primarySpAddress = object.primarySpAddress ?? "";
    return message;
  }

};

function createBaseEventUpdateBucketInfo(): EventUpdateBucketInfo {
  return {
    operatorAddress: "",
    bucketName: "",
    id: "",
    readQuotaBefore: 0,
    readQuotaAfter: 0,
    paymentAddressBefore: "",
    paymentAddressAfter: ""
  };
}

export const EventUpdateBucketInfo = {
  encode(message: EventUpdateBucketInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.operatorAddress !== "") {
      writer.uint32(10).string(message.operatorAddress);
    }

    if (message.bucketName !== "") {
      writer.uint32(18).string(message.bucketName);
    }

    if (message.id !== "") {
      writer.uint32(26).string(message.id);
    }

    if (message.readQuotaBefore !== 0) {
      writer.uint32(32).int32(message.readQuotaBefore);
    }

    if (message.readQuotaAfter !== 0) {
      writer.uint32(40).int32(message.readQuotaAfter);
    }

    if (message.paymentAddressBefore !== "") {
      writer.uint32(50).string(message.paymentAddressBefore);
    }

    if (message.paymentAddressAfter !== "") {
      writer.uint32(58).string(message.paymentAddressAfter);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventUpdateBucketInfo {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventUpdateBucketInfo();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.operatorAddress = reader.string();
          break;

        case 2:
          message.bucketName = reader.string();
          break;

        case 3:
          message.id = reader.string();
          break;

        case 4:
          message.readQuotaBefore = (reader.int32() as any);
          break;

        case 5:
          message.readQuotaAfter = (reader.int32() as any);
          break;

        case 6:
          message.paymentAddressBefore = reader.string();
          break;

        case 7:
          message.paymentAddressAfter = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): EventUpdateBucketInfo {
    return {
      operatorAddress: isSet(object.operatorAddress) ? String(object.operatorAddress) : "",
      bucketName: isSet(object.bucketName) ? String(object.bucketName) : "",
      id: isSet(object.id) ? String(object.id) : "",
      readQuotaBefore: isSet(object.readQuotaBefore) ? readQuotaFromJSON(object.readQuotaBefore) : 0,
      readQuotaAfter: isSet(object.readQuotaAfter) ? readQuotaFromJSON(object.readQuotaAfter) : 0,
      paymentAddressBefore: isSet(object.paymentAddressBefore) ? String(object.paymentAddressBefore) : "",
      paymentAddressAfter: isSet(object.paymentAddressAfter) ? String(object.paymentAddressAfter) : ""
    };
  },

  toJSON(message: EventUpdateBucketInfo): unknown {
    const obj: any = {};
    message.operatorAddress !== undefined && (obj.operatorAddress = message.operatorAddress);
    message.bucketName !== undefined && (obj.bucketName = message.bucketName);
    message.id !== undefined && (obj.id = message.id);
    message.readQuotaBefore !== undefined && (obj.readQuotaBefore = readQuotaToJSON(message.readQuotaBefore));
    message.readQuotaAfter !== undefined && (obj.readQuotaAfter = readQuotaToJSON(message.readQuotaAfter));
    message.paymentAddressBefore !== undefined && (obj.paymentAddressBefore = message.paymentAddressBefore);
    message.paymentAddressAfter !== undefined && (obj.paymentAddressAfter = message.paymentAddressAfter);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EventUpdateBucketInfo>, I>>(object: I): EventUpdateBucketInfo {
    const message = createBaseEventUpdateBucketInfo();
    message.operatorAddress = object.operatorAddress ?? "";
    message.bucketName = object.bucketName ?? "";
    message.id = object.id ?? "";
    message.readQuotaBefore = object.readQuotaBefore ?? 0;
    message.readQuotaAfter = object.readQuotaAfter ?? 0;
    message.paymentAddressBefore = object.paymentAddressBefore ?? "";
    message.paymentAddressAfter = object.paymentAddressAfter ?? "";
    return message;
  }

};

function createBaseEventCreateObject(): EventCreateObject {
  return {
    creatorAddress: "",
    ownerAddress: "",
    bucketName: "",
    objectName: "",
    id: "",
    primarySpAddress: "",
    payloadSize: Long.UZERO,
    isPublic: false,
    contentType: "",
    createAt: Long.ZERO,
    status: 0,
    redundancyType: 0,
    sourceType: 0,
    checksums: []
  };
}

export const EventCreateObject = {
  encode(message: EventCreateObject, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.creatorAddress !== "") {
      writer.uint32(10).string(message.creatorAddress);
    }

    if (message.ownerAddress !== "") {
      writer.uint32(18).string(message.ownerAddress);
    }

    if (message.bucketName !== "") {
      writer.uint32(26).string(message.bucketName);
    }

    if (message.objectName !== "") {
      writer.uint32(34).string(message.objectName);
    }

    if (message.id !== "") {
      writer.uint32(50).string(message.id);
    }

    if (message.primarySpAddress !== "") {
      writer.uint32(58).string(message.primarySpAddress);
    }

    if (!message.payloadSize.isZero()) {
      writer.uint32(64).uint64(message.payloadSize);
    }

    if (message.isPublic === true) {
      writer.uint32(72).bool(message.isPublic);
    }

    if (message.contentType !== "") {
      writer.uint32(82).string(message.contentType);
    }

    if (!message.createAt.isZero()) {
      writer.uint32(88).int64(message.createAt);
    }

    if (message.status !== 0) {
      writer.uint32(96).int32(message.status);
    }

    if (message.redundancyType !== 0) {
      writer.uint32(104).int32(message.redundancyType);
    }

    if (message.sourceType !== 0) {
      writer.uint32(112).int32(message.sourceType);
    }

    for (const v of message.checksums) {
      writer.uint32(122).bytes(v!);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventCreateObject {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventCreateObject();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.creatorAddress = reader.string();
          break;

        case 2:
          message.ownerAddress = reader.string();
          break;

        case 3:
          message.bucketName = reader.string();
          break;

        case 4:
          message.objectName = reader.string();
          break;

        case 6:
          message.id = reader.string();
          break;

        case 7:
          message.primarySpAddress = reader.string();
          break;

        case 8:
          message.payloadSize = (reader.uint64() as Long);
          break;

        case 9:
          message.isPublic = reader.bool();
          break;

        case 10:
          message.contentType = reader.string();
          break;

        case 11:
          message.createAt = (reader.int64() as Long);
          break;

        case 12:
          message.status = (reader.int32() as any);
          break;

        case 13:
          message.redundancyType = (reader.int32() as any);
          break;

        case 14:
          message.sourceType = (reader.int32() as any);
          break;

        case 15:
          message.checksums.push(reader.bytes());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): EventCreateObject {
    return {
      creatorAddress: isSet(object.creatorAddress) ? String(object.creatorAddress) : "",
      ownerAddress: isSet(object.ownerAddress) ? String(object.ownerAddress) : "",
      bucketName: isSet(object.bucketName) ? String(object.bucketName) : "",
      objectName: isSet(object.objectName) ? String(object.objectName) : "",
      id: isSet(object.id) ? String(object.id) : "",
      primarySpAddress: isSet(object.primarySpAddress) ? String(object.primarySpAddress) : "",
      payloadSize: isSet(object.payloadSize) ? Long.fromValue(object.payloadSize) : Long.UZERO,
      isPublic: isSet(object.isPublic) ? Boolean(object.isPublic) : false,
      contentType: isSet(object.contentType) ? String(object.contentType) : "",
      createAt: isSet(object.createAt) ? Long.fromValue(object.createAt) : Long.ZERO,
      status: isSet(object.status) ? objectStatusFromJSON(object.status) : 0,
      redundancyType: isSet(object.redundancyType) ? redundancyTypeFromJSON(object.redundancyType) : 0,
      sourceType: isSet(object.sourceType) ? sourceTypeFromJSON(object.sourceType) : 0,
      checksums: Array.isArray(object?.checksums) ? object.checksums.map((e: any) => bytesFromBase64(e)) : []
    };
  },

  toJSON(message: EventCreateObject): unknown {
    const obj: any = {};
    message.creatorAddress !== undefined && (obj.creatorAddress = message.creatorAddress);
    message.ownerAddress !== undefined && (obj.ownerAddress = message.ownerAddress);
    message.bucketName !== undefined && (obj.bucketName = message.bucketName);
    message.objectName !== undefined && (obj.objectName = message.objectName);
    message.id !== undefined && (obj.id = message.id);
    message.primarySpAddress !== undefined && (obj.primarySpAddress = message.primarySpAddress);
    message.payloadSize !== undefined && (obj.payloadSize = (message.payloadSize || Long.UZERO).toString());
    message.isPublic !== undefined && (obj.isPublic = message.isPublic);
    message.contentType !== undefined && (obj.contentType = message.contentType);
    message.createAt !== undefined && (obj.createAt = (message.createAt || Long.ZERO).toString());
    message.status !== undefined && (obj.status = objectStatusToJSON(message.status));
    message.redundancyType !== undefined && (obj.redundancyType = redundancyTypeToJSON(message.redundancyType));
    message.sourceType !== undefined && (obj.sourceType = sourceTypeToJSON(message.sourceType));

    if (message.checksums) {
      obj.checksums = message.checksums.map(e => base64FromBytes(e !== undefined ? e : new Uint8Array()));
    } else {
      obj.checksums = [];
    }

    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EventCreateObject>, I>>(object: I): EventCreateObject {
    const message = createBaseEventCreateObject();
    message.creatorAddress = object.creatorAddress ?? "";
    message.ownerAddress = object.ownerAddress ?? "";
    message.bucketName = object.bucketName ?? "";
    message.objectName = object.objectName ?? "";
    message.id = object.id ?? "";
    message.primarySpAddress = object.primarySpAddress ?? "";
    message.payloadSize = object.payloadSize !== undefined && object.payloadSize !== null ? Long.fromValue(object.payloadSize) : Long.UZERO;
    message.isPublic = object.isPublic ?? false;
    message.contentType = object.contentType ?? "";
    message.createAt = object.createAt !== undefined && object.createAt !== null ? Long.fromValue(object.createAt) : Long.ZERO;
    message.status = object.status ?? 0;
    message.redundancyType = object.redundancyType ?? 0;
    message.sourceType = object.sourceType ?? 0;
    message.checksums = object.checksums?.map(e => e) || [];
    return message;
  }

};

function createBaseEventCancelCreateObject(): EventCancelCreateObject {
  return {
    operatorAddress: "",
    bucketName: "",
    objectName: "",
    primarySpAddress: "",
    id: ""
  };
}

export const EventCancelCreateObject = {
  encode(message: EventCancelCreateObject, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.operatorAddress !== "") {
      writer.uint32(10).string(message.operatorAddress);
    }

    if (message.bucketName !== "") {
      writer.uint32(18).string(message.bucketName);
    }

    if (message.objectName !== "") {
      writer.uint32(26).string(message.objectName);
    }

    if (message.primarySpAddress !== "") {
      writer.uint32(34).string(message.primarySpAddress);
    }

    if (message.id !== "") {
      writer.uint32(50).string(message.id);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventCancelCreateObject {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventCancelCreateObject();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.operatorAddress = reader.string();
          break;

        case 2:
          message.bucketName = reader.string();
          break;

        case 3:
          message.objectName = reader.string();
          break;

        case 4:
          message.primarySpAddress = reader.string();
          break;

        case 6:
          message.id = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): EventCancelCreateObject {
    return {
      operatorAddress: isSet(object.operatorAddress) ? String(object.operatorAddress) : "",
      bucketName: isSet(object.bucketName) ? String(object.bucketName) : "",
      objectName: isSet(object.objectName) ? String(object.objectName) : "",
      primarySpAddress: isSet(object.primarySpAddress) ? String(object.primarySpAddress) : "",
      id: isSet(object.id) ? String(object.id) : ""
    };
  },

  toJSON(message: EventCancelCreateObject): unknown {
    const obj: any = {};
    message.operatorAddress !== undefined && (obj.operatorAddress = message.operatorAddress);
    message.bucketName !== undefined && (obj.bucketName = message.bucketName);
    message.objectName !== undefined && (obj.objectName = message.objectName);
    message.primarySpAddress !== undefined && (obj.primarySpAddress = message.primarySpAddress);
    message.id !== undefined && (obj.id = message.id);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EventCancelCreateObject>, I>>(object: I): EventCancelCreateObject {
    const message = createBaseEventCancelCreateObject();
    message.operatorAddress = object.operatorAddress ?? "";
    message.bucketName = object.bucketName ?? "";
    message.objectName = object.objectName ?? "";
    message.primarySpAddress = object.primarySpAddress ?? "";
    message.id = object.id ?? "";
    return message;
  }

};

function createBaseEventSealObject(): EventSealObject {
  return {
    operatorAddress: "",
    bucketName: "",
    objectName: "",
    id: "",
    status: 0,
    secondarySpAddress: []
  };
}

export const EventSealObject = {
  encode(message: EventSealObject, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.operatorAddress !== "") {
      writer.uint32(10).string(message.operatorAddress);
    }

    if (message.bucketName !== "") {
      writer.uint32(18).string(message.bucketName);
    }

    if (message.objectName !== "") {
      writer.uint32(26).string(message.objectName);
    }

    if (message.id !== "") {
      writer.uint32(42).string(message.id);
    }

    if (message.status !== 0) {
      writer.uint32(48).int32(message.status);
    }

    for (const v of message.secondarySpAddress) {
      writer.uint32(58).string(v!);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventSealObject {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventSealObject();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.operatorAddress = reader.string();
          break;

        case 2:
          message.bucketName = reader.string();
          break;

        case 3:
          message.objectName = reader.string();
          break;

        case 5:
          message.id = reader.string();
          break;

        case 6:
          message.status = (reader.int32() as any);
          break;

        case 7:
          message.secondarySpAddress.push(reader.string());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): EventSealObject {
    return {
      operatorAddress: isSet(object.operatorAddress) ? String(object.operatorAddress) : "",
      bucketName: isSet(object.bucketName) ? String(object.bucketName) : "",
      objectName: isSet(object.objectName) ? String(object.objectName) : "",
      id: isSet(object.id) ? String(object.id) : "",
      status: isSet(object.status) ? objectStatusFromJSON(object.status) : 0,
      secondarySpAddress: Array.isArray(object?.secondarySpAddress) ? object.secondarySpAddress.map((e: any) => String(e)) : []
    };
  },

  toJSON(message: EventSealObject): unknown {
    const obj: any = {};
    message.operatorAddress !== undefined && (obj.operatorAddress = message.operatorAddress);
    message.bucketName !== undefined && (obj.bucketName = message.bucketName);
    message.objectName !== undefined && (obj.objectName = message.objectName);
    message.id !== undefined && (obj.id = message.id);
    message.status !== undefined && (obj.status = objectStatusToJSON(message.status));

    if (message.secondarySpAddress) {
      obj.secondarySpAddress = message.secondarySpAddress.map(e => e);
    } else {
      obj.secondarySpAddress = [];
    }

    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EventSealObject>, I>>(object: I): EventSealObject {
    const message = createBaseEventSealObject();
    message.operatorAddress = object.operatorAddress ?? "";
    message.bucketName = object.bucketName ?? "";
    message.objectName = object.objectName ?? "";
    message.id = object.id ?? "";
    message.status = object.status ?? 0;
    message.secondarySpAddress = object.secondarySpAddress?.map(e => e) || [];
    return message;
  }

};

function createBaseEventCopyObject(): EventCopyObject {
  return {
    operatorAddress: "",
    srcBucketName: "",
    srcObjectName: "",
    dstBucketName: "",
    dstObjectName: "",
    srcObjectId: "",
    dstObjectId: ""
  };
}

export const EventCopyObject = {
  encode(message: EventCopyObject, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.operatorAddress !== "") {
      writer.uint32(10).string(message.operatorAddress);
    }

    if (message.srcBucketName !== "") {
      writer.uint32(18).string(message.srcBucketName);
    }

    if (message.srcObjectName !== "") {
      writer.uint32(26).string(message.srcObjectName);
    }

    if (message.dstBucketName !== "") {
      writer.uint32(34).string(message.dstBucketName);
    }

    if (message.dstObjectName !== "") {
      writer.uint32(42).string(message.dstObjectName);
    }

    if (message.srcObjectId !== "") {
      writer.uint32(50).string(message.srcObjectId);
    }

    if (message.dstObjectId !== "") {
      writer.uint32(58).string(message.dstObjectId);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventCopyObject {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventCopyObject();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.operatorAddress = reader.string();
          break;

        case 2:
          message.srcBucketName = reader.string();
          break;

        case 3:
          message.srcObjectName = reader.string();
          break;

        case 4:
          message.dstBucketName = reader.string();
          break;

        case 5:
          message.dstObjectName = reader.string();
          break;

        case 6:
          message.srcObjectId = reader.string();
          break;

        case 7:
          message.dstObjectId = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): EventCopyObject {
    return {
      operatorAddress: isSet(object.operatorAddress) ? String(object.operatorAddress) : "",
      srcBucketName: isSet(object.srcBucketName) ? String(object.srcBucketName) : "",
      srcObjectName: isSet(object.srcObjectName) ? String(object.srcObjectName) : "",
      dstBucketName: isSet(object.dstBucketName) ? String(object.dstBucketName) : "",
      dstObjectName: isSet(object.dstObjectName) ? String(object.dstObjectName) : "",
      srcObjectId: isSet(object.srcObjectId) ? String(object.srcObjectId) : "",
      dstObjectId: isSet(object.dstObjectId) ? String(object.dstObjectId) : ""
    };
  },

  toJSON(message: EventCopyObject): unknown {
    const obj: any = {};
    message.operatorAddress !== undefined && (obj.operatorAddress = message.operatorAddress);
    message.srcBucketName !== undefined && (obj.srcBucketName = message.srcBucketName);
    message.srcObjectName !== undefined && (obj.srcObjectName = message.srcObjectName);
    message.dstBucketName !== undefined && (obj.dstBucketName = message.dstBucketName);
    message.dstObjectName !== undefined && (obj.dstObjectName = message.dstObjectName);
    message.srcObjectId !== undefined && (obj.srcObjectId = message.srcObjectId);
    message.dstObjectId !== undefined && (obj.dstObjectId = message.dstObjectId);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EventCopyObject>, I>>(object: I): EventCopyObject {
    const message = createBaseEventCopyObject();
    message.operatorAddress = object.operatorAddress ?? "";
    message.srcBucketName = object.srcBucketName ?? "";
    message.srcObjectName = object.srcObjectName ?? "";
    message.dstBucketName = object.dstBucketName ?? "";
    message.dstObjectName = object.dstObjectName ?? "";
    message.srcObjectId = object.srcObjectId ?? "";
    message.dstObjectId = object.dstObjectId ?? "";
    return message;
  }

};

function createBaseEventDeleteObject(): EventDeleteObject {
  return {
    operatorAddress: "",
    bucketName: "",
    objectName: "",
    id: "",
    primarySpAddress: "",
    secondarySpAddresses: []
  };
}

export const EventDeleteObject = {
  encode(message: EventDeleteObject, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.operatorAddress !== "") {
      writer.uint32(10).string(message.operatorAddress);
    }

    if (message.bucketName !== "") {
      writer.uint32(18).string(message.bucketName);
    }

    if (message.objectName !== "") {
      writer.uint32(26).string(message.objectName);
    }

    if (message.id !== "") {
      writer.uint32(34).string(message.id);
    }

    if (message.primarySpAddress !== "") {
      writer.uint32(42).string(message.primarySpAddress);
    }

    for (const v of message.secondarySpAddresses) {
      writer.uint32(50).string(v!);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventDeleteObject {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventDeleteObject();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.operatorAddress = reader.string();
          break;

        case 2:
          message.bucketName = reader.string();
          break;

        case 3:
          message.objectName = reader.string();
          break;

        case 4:
          message.id = reader.string();
          break;

        case 5:
          message.primarySpAddress = reader.string();
          break;

        case 6:
          message.secondarySpAddresses.push(reader.string());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): EventDeleteObject {
    return {
      operatorAddress: isSet(object.operatorAddress) ? String(object.operatorAddress) : "",
      bucketName: isSet(object.bucketName) ? String(object.bucketName) : "",
      objectName: isSet(object.objectName) ? String(object.objectName) : "",
      id: isSet(object.id) ? String(object.id) : "",
      primarySpAddress: isSet(object.primarySpAddress) ? String(object.primarySpAddress) : "",
      secondarySpAddresses: Array.isArray(object?.secondarySpAddresses) ? object.secondarySpAddresses.map((e: any) => String(e)) : []
    };
  },

  toJSON(message: EventDeleteObject): unknown {
    const obj: any = {};
    message.operatorAddress !== undefined && (obj.operatorAddress = message.operatorAddress);
    message.bucketName !== undefined && (obj.bucketName = message.bucketName);
    message.objectName !== undefined && (obj.objectName = message.objectName);
    message.id !== undefined && (obj.id = message.id);
    message.primarySpAddress !== undefined && (obj.primarySpAddress = message.primarySpAddress);

    if (message.secondarySpAddresses) {
      obj.secondarySpAddresses = message.secondarySpAddresses.map(e => e);
    } else {
      obj.secondarySpAddresses = [];
    }

    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EventDeleteObject>, I>>(object: I): EventDeleteObject {
    const message = createBaseEventDeleteObject();
    message.operatorAddress = object.operatorAddress ?? "";
    message.bucketName = object.bucketName ?? "";
    message.objectName = object.objectName ?? "";
    message.id = object.id ?? "";
    message.primarySpAddress = object.primarySpAddress ?? "";
    message.secondarySpAddresses = object.secondarySpAddresses?.map(e => e) || [];
    return message;
  }

};

function createBaseEventRejectSealObject(): EventRejectSealObject {
  return {
    operatorAddress: "",
    bucketName: "",
    objectName: "",
    id: ""
  };
}

export const EventRejectSealObject = {
  encode(message: EventRejectSealObject, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.operatorAddress !== "") {
      writer.uint32(10).string(message.operatorAddress);
    }

    if (message.bucketName !== "") {
      writer.uint32(18).string(message.bucketName);
    }

    if (message.objectName !== "") {
      writer.uint32(26).string(message.objectName);
    }

    if (message.id !== "") {
      writer.uint32(34).string(message.id);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventRejectSealObject {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventRejectSealObject();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.operatorAddress = reader.string();
          break;

        case 2:
          message.bucketName = reader.string();
          break;

        case 3:
          message.objectName = reader.string();
          break;

        case 4:
          message.id = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): EventRejectSealObject {
    return {
      operatorAddress: isSet(object.operatorAddress) ? String(object.operatorAddress) : "",
      bucketName: isSet(object.bucketName) ? String(object.bucketName) : "",
      objectName: isSet(object.objectName) ? String(object.objectName) : "",
      id: isSet(object.id) ? String(object.id) : ""
    };
  },

  toJSON(message: EventRejectSealObject): unknown {
    const obj: any = {};
    message.operatorAddress !== undefined && (obj.operatorAddress = message.operatorAddress);
    message.bucketName !== undefined && (obj.bucketName = message.bucketName);
    message.objectName !== undefined && (obj.objectName = message.objectName);
    message.id !== undefined && (obj.id = message.id);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EventRejectSealObject>, I>>(object: I): EventRejectSealObject {
    const message = createBaseEventRejectSealObject();
    message.operatorAddress = object.operatorAddress ?? "";
    message.bucketName = object.bucketName ?? "";
    message.objectName = object.objectName ?? "";
    message.id = object.id ?? "";
    return message;
  }

};

function createBaseEventCreateGroup(): EventCreateGroup {
  return {
    ownerAddress: "",
    groupName: "",
    id: "",
    sourceType: 0,
    members: []
  };
}

export const EventCreateGroup = {
  encode(message: EventCreateGroup, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ownerAddress !== "") {
      writer.uint32(10).string(message.ownerAddress);
    }

    if (message.groupName !== "") {
      writer.uint32(18).string(message.groupName);
    }

    if (message.id !== "") {
      writer.uint32(26).string(message.id);
    }

    if (message.sourceType !== 0) {
      writer.uint32(32).int32(message.sourceType);
    }

    for (const v of message.members) {
      writer.uint32(42).string(v!);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventCreateGroup {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventCreateGroup();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.ownerAddress = reader.string();
          break;

        case 2:
          message.groupName = reader.string();
          break;

        case 3:
          message.id = reader.string();
          break;

        case 4:
          message.sourceType = (reader.int32() as any);
          break;

        case 5:
          message.members.push(reader.string());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): EventCreateGroup {
    return {
      ownerAddress: isSet(object.ownerAddress) ? String(object.ownerAddress) : "",
      groupName: isSet(object.groupName) ? String(object.groupName) : "",
      id: isSet(object.id) ? String(object.id) : "",
      sourceType: isSet(object.sourceType) ? sourceTypeFromJSON(object.sourceType) : 0,
      members: Array.isArray(object?.members) ? object.members.map((e: any) => String(e)) : []
    };
  },

  toJSON(message: EventCreateGroup): unknown {
    const obj: any = {};
    message.ownerAddress !== undefined && (obj.ownerAddress = message.ownerAddress);
    message.groupName !== undefined && (obj.groupName = message.groupName);
    message.id !== undefined && (obj.id = message.id);
    message.sourceType !== undefined && (obj.sourceType = sourceTypeToJSON(message.sourceType));

    if (message.members) {
      obj.members = message.members.map(e => e);
    } else {
      obj.members = [];
    }

    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EventCreateGroup>, I>>(object: I): EventCreateGroup {
    const message = createBaseEventCreateGroup();
    message.ownerAddress = object.ownerAddress ?? "";
    message.groupName = object.groupName ?? "";
    message.id = object.id ?? "";
    message.sourceType = object.sourceType ?? 0;
    message.members = object.members?.map(e => e) || [];
    return message;
  }

};

function createBaseEventDeleteGroup(): EventDeleteGroup {
  return {
    ownerAddress: "",
    groupName: "",
    id: ""
  };
}

export const EventDeleteGroup = {
  encode(message: EventDeleteGroup, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ownerAddress !== "") {
      writer.uint32(18).string(message.ownerAddress);
    }

    if (message.groupName !== "") {
      writer.uint32(26).string(message.groupName);
    }

    if (message.id !== "") {
      writer.uint32(34).string(message.id);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventDeleteGroup {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventDeleteGroup();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 2:
          message.ownerAddress = reader.string();
          break;

        case 3:
          message.groupName = reader.string();
          break;

        case 4:
          message.id = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): EventDeleteGroup {
    return {
      ownerAddress: isSet(object.ownerAddress) ? String(object.ownerAddress) : "",
      groupName: isSet(object.groupName) ? String(object.groupName) : "",
      id: isSet(object.id) ? String(object.id) : ""
    };
  },

  toJSON(message: EventDeleteGroup): unknown {
    const obj: any = {};
    message.ownerAddress !== undefined && (obj.ownerAddress = message.ownerAddress);
    message.groupName !== undefined && (obj.groupName = message.groupName);
    message.id !== undefined && (obj.id = message.id);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EventDeleteGroup>, I>>(object: I): EventDeleteGroup {
    const message = createBaseEventDeleteGroup();
    message.ownerAddress = object.ownerAddress ?? "";
    message.groupName = object.groupName ?? "";
    message.id = object.id ?? "";
    return message;
  }

};

function createBaseEventLeaveGroup(): EventLeaveGroup {
  return {
    memberAddress: "",
    ownerAddress: "",
    groupName: "",
    id: ""
  };
}

export const EventLeaveGroup = {
  encode(message: EventLeaveGroup, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.memberAddress !== "") {
      writer.uint32(10).string(message.memberAddress);
    }

    if (message.ownerAddress !== "") {
      writer.uint32(18).string(message.ownerAddress);
    }

    if (message.groupName !== "") {
      writer.uint32(26).string(message.groupName);
    }

    if (message.id !== "") {
      writer.uint32(34).string(message.id);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventLeaveGroup {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventLeaveGroup();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.memberAddress = reader.string();
          break;

        case 2:
          message.ownerAddress = reader.string();
          break;

        case 3:
          message.groupName = reader.string();
          break;

        case 4:
          message.id = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): EventLeaveGroup {
    return {
      memberAddress: isSet(object.memberAddress) ? String(object.memberAddress) : "",
      ownerAddress: isSet(object.ownerAddress) ? String(object.ownerAddress) : "",
      groupName: isSet(object.groupName) ? String(object.groupName) : "",
      id: isSet(object.id) ? String(object.id) : ""
    };
  },

  toJSON(message: EventLeaveGroup): unknown {
    const obj: any = {};
    message.memberAddress !== undefined && (obj.memberAddress = message.memberAddress);
    message.ownerAddress !== undefined && (obj.ownerAddress = message.ownerAddress);
    message.groupName !== undefined && (obj.groupName = message.groupName);
    message.id !== undefined && (obj.id = message.id);
    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EventLeaveGroup>, I>>(object: I): EventLeaveGroup {
    const message = createBaseEventLeaveGroup();
    message.memberAddress = object.memberAddress ?? "";
    message.ownerAddress = object.ownerAddress ?? "";
    message.groupName = object.groupName ?? "";
    message.id = object.id ?? "";
    return message;
  }

};

function createBaseEventUpdateGroupMember(): EventUpdateGroupMember {
  return {
    operatorAddress: "",
    ownerAddress: "",
    groupName: "",
    id: "",
    membersToAdd: [],
    membersToDelete: []
  };
}

export const EventUpdateGroupMember = {
  encode(message: EventUpdateGroupMember, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.operatorAddress !== "") {
      writer.uint32(10).string(message.operatorAddress);
    }

    if (message.ownerAddress !== "") {
      writer.uint32(18).string(message.ownerAddress);
    }

    if (message.groupName !== "") {
      writer.uint32(26).string(message.groupName);
    }

    if (message.id !== "") {
      writer.uint32(34).string(message.id);
    }

    for (const v of message.membersToAdd) {
      writer.uint32(42).string(v!);
    }

    for (const v of message.membersToDelete) {
      writer.uint32(50).string(v!);
    }

    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): EventUpdateGroupMember {
    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventUpdateGroupMember();

    while (reader.pos < end) {
      const tag = reader.uint32();

      switch (tag >>> 3) {
        case 1:
          message.operatorAddress = reader.string();
          break;

        case 2:
          message.ownerAddress = reader.string();
          break;

        case 3:
          message.groupName = reader.string();
          break;

        case 4:
          message.id = reader.string();
          break;

        case 5:
          message.membersToAdd.push(reader.string());
          break;

        case 6:
          message.membersToDelete.push(reader.string());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  },

  fromJSON(object: any): EventUpdateGroupMember {
    return {
      operatorAddress: isSet(object.operatorAddress) ? String(object.operatorAddress) : "",
      ownerAddress: isSet(object.ownerAddress) ? String(object.ownerAddress) : "",
      groupName: isSet(object.groupName) ? String(object.groupName) : "",
      id: isSet(object.id) ? String(object.id) : "",
      membersToAdd: Array.isArray(object?.membersToAdd) ? object.membersToAdd.map((e: any) => String(e)) : [],
      membersToDelete: Array.isArray(object?.membersToDelete) ? object.membersToDelete.map((e: any) => String(e)) : []
    };
  },

  toJSON(message: EventUpdateGroupMember): unknown {
    const obj: any = {};
    message.operatorAddress !== undefined && (obj.operatorAddress = message.operatorAddress);
    message.ownerAddress !== undefined && (obj.ownerAddress = message.ownerAddress);
    message.groupName !== undefined && (obj.groupName = message.groupName);
    message.id !== undefined && (obj.id = message.id);

    if (message.membersToAdd) {
      obj.membersToAdd = message.membersToAdd.map(e => e);
    } else {
      obj.membersToAdd = [];
    }

    if (message.membersToDelete) {
      obj.membersToDelete = message.membersToDelete.map(e => e);
    } else {
      obj.membersToDelete = [];
    }

    return obj;
  },

  fromPartial<I extends Exact<DeepPartial<EventUpdateGroupMember>, I>>(object: I): EventUpdateGroupMember {
    const message = createBaseEventUpdateGroupMember();
    message.operatorAddress = object.operatorAddress ?? "";
    message.ownerAddress = object.ownerAddress ?? "";
    message.groupName = object.groupName ?? "";
    message.id = object.id ?? "";
    message.membersToAdd = object.membersToAdd?.map(e => e) || [];
    message.membersToDelete = object.membersToDelete?.map(e => e) || [];
    return message;
  }

};